(define (map fn seq)
  (if (null? seq)
      ()
      (cons (fn (car seq)) (map fn (cdr seq)))))

(define (max x y)
  (if (> x y)
      x
      y))

(define (min x y)
  (if (< x y)
      x
      y))

(define (even? x)
  (and (integer? x)
       (= 0 (% x 2))))

(define (odd? x)
  (and (integer? x)
       (not (even? x))))

(define (include . files)
    (if (null? files)
        (error "include requires at least one file")
        (letrec ((include-files
                  (lambda (files)
                    (let* ((file (car files))
                           (rest (cdr files))
                           (val (load file)))
                      (if (or (error-object? val) (null? rest))
                          val
                          (include-files rest))))))
          (include-files files))))

(define (substring str start end)
  (string-copy str start end))

;;; taken directly from the R7RS specification p. 68
;;
(define-syntax cond
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))

(define (length lst)
  (letrec ((list-length
            (lambda (l)
              (if (null? l)
                  0
                  (+ 1 (list-length (cdr l)))))))
    (if (list? lst)
        (list-length lst)
        (error :args "length: expected a list, got: %{0}" lst))))

(define (type-helper=? pred bs)
  (if (null? bs)
      #t
      (if (= 1 (length bs))
          (pred (car bs))
          (let ((fst (car bs))
                (snd (cadr bs))
                (rst (cdr bs)))
            (and (pred fst)
                 (eqv? fst snd)
                 (type-helper=? pred rst))))))

(define (boolean=? b1 b2 . bs)
  (type-helper=? boolean? (cons b1 (cons b2 bs))))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (reverse lst)
  (letrec ((list-reverse
            (lambda (l)
              (if (null? l)
                  l
                  (append (reverse (cdr l)) (list (car l)))))))
    (if (list? lst)
        (list-reverse lst)
        (error :args "reverse expected a list, got: %{0}" lst))))